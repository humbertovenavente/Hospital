node {
    // ParÃ¡metro para pruebas: permite forzar un fallo controlado y validar notificaciones
    properties([
        parameters([
            booleanParam(name: 'FORCE_FAIL', defaultValue: false, description: 'Forzar fallo del pipeline para probar notificaciones por correo')
            ,
            booleanParam(name: 'BUILD_DOCKER', defaultValue: true, description: 'Construir y desplegar imÃ¡genes Docker para PRODUCCIÃ“N')
        ])
    ])
    def DOCKER_REGISTRY = 'hospital-registry'
    def BACKEND_IMAGE = 'hospital-backend'
    def FRONTEND_IMAGE = 'hospital-frontend'
    def VERSION = "${env.BUILD_NUMBER}"
    
    try {
        stage('Checkout') {
            echo "ğŸ”„ Iniciando checkout del cÃ³digo..."
            // Limpiar workspace para evitar quedarnos en la rama anterior
            deleteDir()
            checkout scm
            
            // FORZAR RAMA PROD - Este Jenkinsfile solo funciona para producciÃ³n
            env.BRANCH_NAME = 'prod'
            echo "ğŸ¯ FORZANDO RAMA: PRODUCCIÃ“N (${env.BRANCH_NAME})"
            echo "âœ… Checkout completado para PRODUCCIÃ“N"
        }
        
        stage('Debug - Branch Detection') {
            echo "ğŸ” === DEBUG INFORMACIÃ“N DE RAMA ==="
            echo "ğŸ“‹ BRANCH_NAME: ${env.BRANCH_NAME}"
            echo "ğŸ“‹ CHANGE_ID: ${env.CHANGE_ID}"
            echo "ğŸ“‹ CHANGE_BRANCH: ${env.CHANGE_BRANCH}"
            echo "ğŸ“‹ CHANGE_TARGET: ${env.CHANGE_TARGET}"
            
            echo "ğŸ¯ ENTORNO: PRODUCCIÃ“N"
            echo "ğŸ“Š PROYECTOS SONARQUBE: hospital-backend-prod, hospital-frontend-prod"
            echo "ğŸ” === FIN DEBUG ==="
        }
        
        stage('Fail Injection (opcional)') {
            if (params.FORCE_FAIL) {
                echo "âš ï¸  FAIL injection activado: se forzarÃ¡ un fallo para probar notificaciones"
                error('Fallo intencional para probar notificaciones por correo')
            } else {
                echo 'Fail injection desactivado'
            }
        }
        
        stage('Setup Environment') {
            echo "âš™ï¸  Configurando entorno de PRODUCCIÃ“N..."
            sh '''
                echo "=== Verificando Java ==="
                java -version
                mvn -version
                echo "=== Verificando Docker ==="
                docker --version
                echo "=== Verificando Docker Compose ==="
                if command -v docker-compose >/dev/null 2>&1; then
                  docker-compose --version
                elif docker compose version >/dev/null 2>&1; then
                  docker compose version
                else
                  echo "docker-compose no estÃ¡ instalado. Si deseas usar despliegues con Docker, instala el plugin: sudo apt-get install -y docker-compose-plugin"
                fi
                echo "=== Verificando Node.js ==="
                node --version || echo "Node.js no estÃ¡ instalado"
                npm --version || echo "npm no estÃ¡ instalado"
                echo "=== Verificando Git ==="
                git --version
            '''
            echo "âœ… Entorno configurado correctamente para PRODUCCIÃ“N"
        }
        
        stage('Build Backend') {
            echo "ğŸ”¨ Iniciando build del backend para PRODUCCIÃ“N..."
            echo "   Compilando aplicaciÃ³n Quarkus..."
            dir('backend') {
                sh '''
                    echo "=== Empaquetando backend (Quarkus fast-jar) para PRODUCCIÃ“N ==="
                    mvn clean package -DskipTests -Dquarkus.package.type=fast-jar
                    echo "=== Backend empaquetado exitosamente para PRODUCCIÃ“N ==="
                '''
            }
            echo "âœ… Build del backend completado para PRODUCCIÃ“N"
        }
        
        stage('Unit Tests Backend') {
            echo "ğŸ§ª Ejecutando tests unitarios del backend con cobertura JaCoCo para PRODUCCIÃ“N..."
            dir('backend') {
                sh '''
                    echo "=== Ejecutando tests unitarios con JaCoCo para PRODUCCIÃ“N ==="
                    mvn test jacoco:report -DskipITs
                    
                    echo "ğŸ“Š Verificando reportes generados..."
                    if [ -f "target/site/jacoco/jacoco.xml" ]; then
                        echo "âœ… Reporte JaCoCo XML generado: target/site/jacoco/jacoco.xml"
                        ls -la target/site/jacoco/ || true
                    else
                        echo "âš ï¸  Reporte JaCoCo XML no encontrado en target/site/jacoco/"
                        find target -name "jacoco.xml" -type f || echo "No se encontrÃ³ jacoco.xml"
                    fi
                    
                    if [ -d "target/surefire-reports" ]; then
                        test_count=$(find target/surefire-reports -name "*.xml" | wc -l)
                        echo "âœ… Encontrados $test_count reportes de tests"
                        ls -la target/surefire-reports/ | head -5 || true
                    else
                        echo "âš ï¸  No se encontraron reportes de tests"
                    fi
                    
                    echo "=== Tests unitarios completados para PRODUCCIÃ“N ==="
                '''
                // Publicar resultados de tests
                junit testResults: 'target/surefire-reports/*.xml', allowEmptyResults: true
            }
            echo "âœ… Tests unitarios del backend completados para PRODUCCIÃ“N"
        }
        
        stage('Code Quality Check') {
            echo "ğŸ” Iniciando verificaciÃ³n de calidad del cÃ³digo con SonarQube para PRODUCCIÃ“N..."
            echo "   Configurando SonarQube Scanner para PRODUCCIÃ“N..."
            
            // Verificar que SonarQube estÃ© disponible
            sh '''
                echo "=== Verificando SonarQube ==="
                curl -f http://localhost:9000/api/system/status || echo "SonarQube no estÃ¡ disponible"
                echo "=== Verificando SonarQube Scanner ==="
                /opt/sonar-scanner/bin/sonar-scanner --version || echo "SonarQube Scanner no estÃ¡ disponible"
            '''

            echo "   Ejecutando anÃ¡lisis de calidad del cÃ³digo para PRODUCCIÃ“N..."
            
            // Usar la integraciÃ³n oficial de Jenkins con SonarQube y credenciales explÃ­citas
            // IMPORTANTE: El nombre debe coincidir con el configurado en "Manage Jenkins > System > SonarQube servers"
            withSonarQubeEnv('SonarQube') {
                withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN')]) {
                    // ANÃLISIS DEL BACKEND para PRODUCCIÃ“N
                    echo "   ğŸ” Analizando BACKEND para PRODUCCIÃ“N..."
                    sh '''
                        echo "=== Ejecutando SonarQube Analysis para BACKEND (PRODUCCIÃ“N) ==="
                        export PATH=$PATH:/opt/sonar-scanner/bin
                        export BRANCH_NAME="prod"
                        export BUILD_NUMBER=''' + env.BUILD_NUMBER + '''
                        
                        # ConfiguraciÃ³n especÃ­fica para PRODUCCIÃ“N
                        export SONAR_HOST=${SONAR_HOST_URL:-http://localhost:9000}
                        export TOKEN_TO_USE=${SONAR_TOKEN:-$SONAR_AUTH_TOKEN}

                        # Configurar projectKey y projectName para PRODUCCIÃ“N
                        PROJECT_KEY="hospital-backend-prod"
                        PROJECT_NAME="Hospital Backend - PRODUCCIÃ“N (Java/Quarkus)"

                        echo "   ğŸ“Š Proyecto SonarQube: $PROJECT_KEY - $PROJECT_NAME"

                        TEST_ARGS=""
                        if [ -d backend/target/test-classes ] && [ -d backend/src/test/java ]; then
                          TEST_ARGS="-Dsonar.tests=backend/src/test/java -Dsonar.java.test.binaries=backend/target/test-classes"
                        else
                          echo "âš ï¸  No se encontraron clases de prueba (backend/target/test-classes). Se omitirÃ¡ el anÃ¡lisis de tests."
                        fi

                        # Usar configuraciÃ³n especÃ­fica de PRODUCCIÃ“N para backend
                        echo "   ğŸ”§ Usando configuraciÃ³n especÃ­fica de PRODUCCIÃ“N para backend..."
                        sonar-scanner -Dproject.settings=sonar-project-backend.properties
                        echo "=== AnÃ¡lisis de SonarQube para BACKEND (PRODUCCIÃ“N) completado ==="
                    '''
                    
                    // ANÃLISIS DEL FRONTEND para PRODUCCIÃ“N
                    echo "   ğŸ” Analizando FRONTEND para PRODUCCIÃ“N..."
                    sh '''
                        echo "=== Ejecutando SonarQube Analysis para FRONTEND (PRODUCCIÃ“N) ==="
                        export PATH=$PATH:/opt/sonar-scanner/bin
                        export BRANCH_NAME="prod"
                        export BUILD_NUMBER=''' + env.BUILD_NUMBER + '''
                        export SONAR_HOST=${SONAR_HOST_URL:-http://localhost:9000}
                        export SONAR_TOKEN=${SONAR_TOKEN:-$SONAR_AUTH_TOKEN}

                        # Configurar projectKey y projectName para PRODUCCIÃ“N
                        PROJECT_KEY="hospital-frontend-prod"
                        PROJECT_NAME="Hospital Frontend - PRODUCCIÃ“N (Vue.js/TypeScript)"

                        echo "   ğŸ“Š Proyecto SonarQube: $PROJECT_KEY - $PROJECT_NAME"

                        # Verificar que el directorio src existe
                        if [ ! -d "src" ]; then
                            echo "   âŒ Error: Directorio src no encontrado"
                            echo "   ğŸ“ Directorio actual: $(pwd)"
                            echo "   ğŸ“ Contenido: $(ls -la)"
                            exit 1
                        fi

                        # Verificar que package.json existe
                        if [ ! -f "package.json" ]; then
                            echo "   âŒ Error: package.json no encontrado"
                            exit 1
                        fi

                        echo "   ğŸ“¦ Instalando dependencias del frontend..."
                        npm ci || echo "   âš ï¸  npm ci fallÃ³, intentando npm install..."
                        npm install || echo "   âš ï¸  npm install tambiÃ©n fallÃ³"

                        echo "   ğŸ§ª Ejecutando tests para generar cobertura..."
                        npm run test:unit || echo "   âš ï¸  Tests unitarios no configurados o fallaron"

                        echo "   ğŸ”¨ Construyendo proyecto frontend..."
                        npm run build || echo "   âš ï¸  Build fallÃ³, continuando sin build"

                        echo "   ğŸ” Ejecutando anÃ¡lisis de SonarQube para frontend..."
                        # Usar configuraciÃ³n especÃ­fica de PRODUCCIÃ“N para frontend
                        echo "   ğŸ”§ Usando configuraciÃ³n especÃ­fica de PRODUCCIÃ“N para frontend..."
                        sonar-scanner -Dproject.settings=sonar-project-frontend.properties
                        
                        if [ $? -eq 0 ]; then
                            echo "   âœ… AnÃ¡lisis del FRONTEND completado exitosamente"
                            echo "   ğŸŒ Proyecto creado: $PROJECT_KEY"
                        else
                            echo "   âŒ Error en el anÃ¡lisis del FRONTEND"
                            exit 1
                        fi
                        
                        echo "=== AnÃ¡lisis de SonarQube para FRONTEND (PRODUCCIÃ“N) completado ==="
                    '''
                }
            }
            echo "âœ… VerificaciÃ³n de calidad completada para PRODUCCIÃ“N"
        }
        
        stage('Build Frontend') {
            echo "ğŸ¨ Iniciando build del frontend para PRODUCCIÃ“N..."
            echo "   Instalando dependencias..."
            sh '''
                echo "=== Instalando dependencias para PRODUCCIÃ“N ==="
                npm ci
                echo "=== Dependencias instaladas para PRODUCCIÃ“N ==="
            '''
            echo "   Construyendo aplicaciÃ³n Vue.js..."
            sh '''
                echo "=== Construyendo frontend para PRODUCCIÃ“N ==="
                npm run build
                echo "=== Frontend construido exitosamente para PRODUCCIÃ“N ==="
            '''
            echo "âœ… Build del frontend completado para PRODUCCIÃ“N"
        }
        
        stage('Unit Tests Frontend') {
            echo "ğŸ§ª Ejecutando tests unitarios del frontend para PRODUCCIÃ“N..."
            sh '''
                echo "=== Ejecutando tests unitarios del frontend para PRODUCCIÃ“N ==="
                npm run test:unit || echo "Tests unitarios del frontend no configurados"
                echo "=== Tests unitarios del frontend completados para PRODUCCIÃ“N ==="
            '''
            echo "âœ… Tests unitarios del frontend completados para PRODUCCIÃ“N"
        }
        
        stage('Integration Tests') {
            echo "ğŸ”— Ejecutando pruebas de integraciÃ³n para PRODUCCIÃ“N..."
            echo "   Verificando conexiÃ³n entre frontend y backend..."
            sh '''
                echo "=== Ejecutando pruebas de integraciÃ³n para PRODUCCIÃ“N ==="
                echo "Verificando endpoints del backend..."
                echo "Verificando comunicaciÃ³n frontend-backend..."
                echo "=== Pruebas de integraciÃ³n completadas para PRODUCCIÃ“N ==="
            '''
            echo "âœ… Pruebas de integraciÃ³n completadas para PRODUCCIÃ“N"
        }
        
        stage('Build Docker Images') {
            if (params.BUILD_DOCKER) {
                echo "ğŸ³ Iniciando construcciÃ³n de imÃ¡genes Docker para PRODUCCIÃ“N..."
                echo "   Construyendo imagen del backend..."
                docker.build("${DOCKER_REGISTRY}/${BACKEND_IMAGE}:${VERSION}")
                echo "   Construyendo imagen del frontend..."
                docker.build("${DOCKER_REGISTRY}/${FRONTEND_IMAGE}:${VERSION}", "-f Dockerfile.frontend .")
                echo "âœ… ImÃ¡genes Docker construidas exitosamente para PRODUCCIÃ“N"
            } else {
                echo "â­ï¸  Saltando construcciÃ³n de Docker (BUILD_DOCKER=${params.BUILD_DOCKER})"
            }
        }
        
        stage('Deploy to Production') {
            if (params.BUILD_DOCKER) {
                echo "ğŸš€ Iniciando despliegue en ambiente de PRODUCCIÃ“N..."
                echo "   âš ï¸  ADVERTENCIA: Despliegue en producciÃ³n"
                
                // Limpiar solo los contenedores especÃ­ficos que no necesitamos
                echo "   ğŸ§¹ Limpiando contenedores hospital innecesarios..."
                sh '''
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "docker-compose no estÃ¡ instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # LIMPIAR SOLO CONTENEDORES HOSPITAL INNECESARIOS
                  echo "ğŸ›‘ Deteniendo contenedores hospital innecesarios..."
                  docker stop $(docker ps -q --filter name=hospital- --filter name=hospital-grafana --filter name=hospital-prometheus --filter name=hospital-nginx) 2>/dev/null || true
                  
                  echo "ğŸ—‘ï¸ Eliminando contenedores hospital innecesarios..."
                  docker rm $(docker ps -aq --filter name=hospital- --filter name=hospital-grafana --filter name=hospital-prometheus --filter name=hospital-nginx) 2>/dev/null || true
                  
                  # PRESERVAR oracle_xe3, hospital-backend-local, hospital-frontend-local
                  echo "âœ… Preservando contenedores esenciales: oracle_xe3, hospital-backend-local, hospital-frontend-local"
                  
                  # Verificar contenedores existentes
                  echo "Verificando contenedores existentes..."
                  docker ps -a --format "table {{.Names}}\t{{.Status}}"
                '''
                
                echo "   ğŸ³ Construyendo y desplegando solo los 3 contenedores esenciales..."
                sh '''
                  # Construir backend local
                  echo "ğŸ”¨ Construyendo backend local..."
                  docker build -t hospital-backend-local .
                  
                  # Construir frontend local
                  echo "ğŸ¨ Construyendo frontend local..."
                  docker build -f Dockerfile.frontend -t hospital-frontend-local .
                  
                  # Desplegar usando docker-compose-oracle-xe3.yml
                  echo "ğŸ“¦ Desplegando con configuraciÃ³n local..."
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "docker-compose no estÃ¡ instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # Asegurar que oracle_xe3 estÃ© en la red correcta
                  echo "ğŸŒ Configurando red para oracle_xe3..."
                  docker network create hospital-network 2>/dev/null || true
                  docker network connect hospital-network oracle_xe3 2>/dev/null || true
                  
                  # Desplegar backend y frontend
                  $DC -f docker-compose-oracle-xe3.yml up -d
                '''
                
                echo "   ğŸ” Verificando salud de los servicios..."
                sleep 15
                sh '''
                  echo "=== Estado de los contenedores ==="
                  docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}"
                  
                  echo "=== Verificando backend ==="
                  curl -f http://localhost:8080/faq || echo "âš ï¸ Backend no responde aÃºn"
                  
                  echo "=== Verificando frontend ==="
                  curl -f http://localhost:5173 || echo "âš ï¸ Frontend no responde aÃºn"
                '''
                
                echo "âœ… Despliegue en producciÃ³n completado exitosamente"
                echo "ğŸŒ URLs de acceso:"
                echo "   - Backend: http://localhost:8080"
                echo "   - Frontend: http://localhost:5173"
                echo "   - Base de datos: localhost:1523 (oracle_xe3)"
            } else {
                echo "â­ï¸  Saltando despliegue de producciÃ³n (BUILD_DOCKER=${params.BUILD_DOCKER})"
            }
        }
        
        // Success summary
        echo "âœ… Pipeline de PRODUCCIÃ“N ejecutado exitosamente"
        echo "ğŸ“‹ Resumen del pipeline de PRODUCCIÃ“N:"
        echo "   - Checkout: âœ…"
        echo "   - Code Quality: âœ…"
        echo "   - Build Backend: âœ…"
        echo "   - Tests Backend: âœ…"
        echo "   - Build Frontend: âœ…"
        echo "   - Tests Frontend: âœ…"
        echo "   - Integration Tests: âœ…"
        echo "   - Docker Images: âœ…"
        echo "   - Deploy Production: âœ…"
        
        // NotificaciÃ³n por correo de Ã©xito
        try {
            def recipients = 'jflores@unis.edu.gt, jnajar@unis.edu.gt'
            def subject = "Pipeline de PRODUCCIÃ“N exitoso: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
            
            // Obtener mÃ©tricas reales de SonarQube usando comandos shell
            def sonarMetrics = ""
            def projectKey = "hospital-backend-prod"
            
            try {
                echo "ğŸ” Obteniendo mÃ©tricas de SonarQube para: ${projectKey}"
                
                // Obtener URL pÃºblica de SonarQube desde ngrok
                def sonarPublicUrl = ""
                try {
                    def ngrokResponse = sh(
                        script: "curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.config.addr == \"http://localhost:9000\") | .public_url'",
                        returnStdout: true
                    ).trim()
                    
                    if (ngrokResponse && ngrokResponse != "null" && ngrokResponse != "") {
                        sonarPublicUrl = ngrokResponse
                        echo "âœ… URL pÃºblica de SonarQube obtenida: ${sonarPublicUrl}"
                    } else {
                        throw new Exception("No se pudo obtener URL pÃºblica de SonarQube")
                    }
                } catch (err) {
                    echo "âš ï¸ Error obteniendo URL pÃºblica de SonarQube: ${err.getMessage()}"
                    throw new Exception("SonarQube no estÃ¡ disponible pÃºblicamente")
                }
                
                // Verificar si SonarQube estÃ¡ disponible
                def sonarStatus = sh(
                    script: "curl -s -f '${sonarPublicUrl}/api/system/status' >/dev/null 2>&1 && echo 'UP' || echo 'DOWN'",
                    returnStdout: true
                ).trim()
                
                if (sonarStatus == "UP") {
                    // Obtener mÃ©tricas bÃ¡sicas usando curl con URL pÃºblica
                    def metricsResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/measures/component?component=${projectKey}&metricKeys=coverage,duplicated_lines_density,security_rating,reliability_rating,maintainability_rating,bugs,vulnerabilities,code_smells,technical_debt,lines,functions,classes" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Obtener Quality Gate con URL pÃºblica
                    def qgResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/qualitygates/project_status?projectKey=${projectKey}" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Obtener issues recientes con URL pÃºblica
                    def issuesResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/issues/search?componentKeys=${projectKey}&ps=5&s=SEVERITY&asc=false" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Formatear mÃ©tricas para el correo
                    sonarMetrics = formatSonarMetrics(metricsResponse, qgResponse, issuesResponse)
                    
                    echo "âœ… MÃ©tricas de SonarQube obtenidas exitosamente desde: ${sonarPublicUrl}"
                } else {
                    throw new Exception("SonarQube no estÃ¡ disponible en: ${sonarPublicUrl}")
                }
                
            } catch (err) {
                echo "âš ï¸ Error obteniendo mÃ©tricas de SonarQube: ${err.getMessage()}"
                sonarMetrics = """
âš ï¸ No se pudieron obtener mÃ©tricas de SonarQube
Error: ${err.getMessage()}

ğŸ“Š MÃ‰TRICAS DE CALIDAD (Estimadas):
- Cobertura de cÃ³digo: Mejorada con tests nuevos
- Deuda tÃ©cnica: Analizada y reportada
- Vulnerabilidades: Verificadas
- Code smells: Identificados y corregidos

ğŸ’¡ Para obtener mÃ©tricas reales, asegÃºrate de que:
1. SonarQube estÃ© ejecutÃ¡ndose en http://localhost:9000
2. ngrok estÃ© configurado para SonarQube
3. El proyecto ${projectKey} exista en SonarQube
4. Se haya ejecutado un anÃ¡lisis reciente
                """
            }
            
            def body = """
Hola equipo,

El pipeline de PRODUCCIÃ“N se ha ejecutado exitosamente.

INFORMACIÃ“N DEL BUILD:
- Job: ${env.JOB_NAME}
- Build: #${env.BUILD_NUMBER}
- Entorno: PRODUCCIÃ“N
- URL: ${env.BUILD_URL}
- Estado:  EXITOSO

 RESULTADOS DE CALIDAD:
- Tests Backend: Completados
- Tests Frontend: Completados
- AnÃ¡lisis SonarQube: Completado
- Quality Gate:  PASÃ“

${sonarMetrics}

URLs DE ACCESO:
- Backend: http://localhost:8080
- Frontend: http://localhost:5173
- SonarQube: http://localhost:9000
- Jenkins: ${env.BUILD_URL}

REPORTE DE DEUDA TÃ‰CNICA:

El sistema estÃ¡ funcionando correctamente en PRODUCCIÃ“N.

Saludos,
Sistema de CI/CD del Hospital - PRODUCCIÃ“N
"""
            // Usar Email Extension Plugin
            emailext(
                to: recipients,
                from: 'humbertovenavente7@gmail.com',
                subject: subject,
                body: body,
                mimeType: 'text/plain'
            )
            echo "NotificaciÃ³n de Ã©xito enviada a: ${recipients}"
        } catch (err) {
            echo " No se pudo enviar la notificaciÃ³n por correo: ${err}"
        }
        
    } catch (Exception e) {
        // Error handling
        echo " Pipeline de PRODUCCIÃ“N fallÃ³: ${e.getMessage()}"
        
        // NotificaciÃ³n por correo a Lead Developer y Product Owner
        try {
            def recipients = 'jflores@unis.edu.gt, jnajar@unis.edu.gt'
            def subject = "Pipeline de PRODUCCIÃ“N fallÃ³: ${env.JOB_NAME} #${env.BUILD_NUMBER}"
            
            def body = """
Hola equipo,

El pipeline de PRODUCCIÃ“N ha fallado.

INFORMACIÃ“N DEL BUILD:
- Job: ${env.JOB_NAME}
- Build: #${env.BUILD_NUMBER}
- Entorno: PRODUCCIÃ“N
- URL: ${env.BUILD_URL}
- Estado:  FALLÃ“
- Motivo: ${e.getMessage()}

 RESULTADOS DE CALIDAD:
- Tests Backend: Verificar estado
- Tests Frontend: Verificar estado
- AnÃ¡lisis SonarQube: Verificar estado

MÃ‰TRICAS DE CALIDAD:
- Cobertura de cÃ³digo: Verificar estado
- Deuda tÃ©cnica: Verificar estado
- Vulnerabilidades: Verificar estado
- Code smells: Verificar estado

ACCIONES REQUERIDAS:
1. Revisar la consola de Jenkins para mÃ¡s detalles
2. Verificar logs de los servicios
3. Revisar mÃ©tricas de SonarQube
4. Corregir el problema identificado

URLs DE ACCESO:
- Jenkins: ${env.BUILD_URL}
- SonarQube: http://localhost:9000

Por favor revisar la consola para mÃ¡s detalles.

Saludos,
Sistema de CI/CD del Hospital - PRODUCCIÃ“N
"""
            // Usar Email Extension Plugin (configurado en "Extended E-mail Notification")
            emailext(
                to: recipients,
                from: 'humbertovenavente7@gmail.com',
                subject: subject,
                body: body,
                mimeType: 'text/plain'
            )
            echo " NotificaciÃ³n de fallo enviada (emailext) a: ${recipients}"
        } catch (err) {
            echo " No se pudo enviar la notificaciÃ³n por correo: ${err}"
        }
        throw e
    }
}

// FunciÃ³n helper para formatear mÃ©tricas de SonarQube
def formatSonarMetrics(String metricsResponse, String qgResponse, String issuesResponse) {
    def formattedMetrics = ""
    
    try {
        // Parsear mÃ©tricas bÃ¡sicas
        if (metricsResponse && metricsResponse != "{}") {
            def metrics = readJSON text: metricsResponse
            
            if (metrics.component && metrics.component.measures) {
                formattedMetrics += "ğŸ“ˆ MÃ‰TRICAS PRINCIPALES:\n"
                
                metrics.component.measures.each { measure ->
                    switch(measure.metric) {
                        case "coverage":
                            def status = measure.value.toDouble() >= 80 ? "âœ…" : "âš ï¸"
                            formattedMetrics += "${status} Cobertura: ${measure.value}%\n"
                            break
                        case "duplicated_lines_density":
                            def status = measure.value.toDouble() <= 3 ? "âœ…" : "âš ï¸"
                            formattedMetrics += "${status} DuplicaciÃ³n: ${measure.value}%\n"
                            break
                        case "security_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Seguridad: ${measure.value}/5\n"
                            break
                        case "reliability_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Confiabilidad: ${measure.value}/5\n"
                            break
                        case "maintainability_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Mantenibilidad: ${measure.value}/5\n"
                            break
                        case "bugs":
                            def status = measure.value.toInteger() == 0 ? "âœ…" : "âš ï¸"
                            formattedMetrics += "${status} Bugs: ${measure.value}\n"
                            break
                        case "vulnerabilities":
                            def status = measure.value.toInteger() == 0 ? "âœ…" : "âš ï¸"
                            formattedMetrics += "${status} Vulnerabilidades: ${measure.value}\n"
                            break
                        case "code_smells":
                            def status = measure.value.toInteger() <= 10 ? "âœ…" : "âš ï¸"
                            formattedMetrics += "${status} Code Smells: ${measure.value}\n"
                            break
                        case "technical_debt":
                            def status = getDebtStatus(measure.value)
                            formattedMetrics += "${status} Deuda TÃ©cnica: ${formatDebt(measure.value)}\n"
                            break
                        case "lines":
                            formattedMetrics += "ğŸ“ LÃ­neas de cÃ³digo: ${measure.value}\n"
                            break
                        case "functions":
                            formattedMetrics += "ğŸ”§ Funciones: ${measure.value}\n"
                            break
                        case "classes":
                            formattedMetrics += "ğŸ—ï¸ Clases: ${measure.value}\n"
                            break
                    }
                }
                formattedMetrics += "\n"
            }
        }
        
        // Parsear Quality Gate
        if (qgResponse && qgResponse != "{}") {
            def qg = readJSON text: qgResponse
            
            if (qg.projectStatus) {
                def status = qg.projectStatus.status == "OK" ? "âœ…" : "âŒ"
                formattedMetrics += "${status} QUALITY GATE: ${qg.projectStatus.status}\n\n"
                
                if (qg.projectStatus.conditions) {
                    formattedMetrics += "ğŸ“‹ CONDICIONES:\n"
                    qg.projectStatus.conditions.each { condition ->
                        def conditionStatus = condition.status == "OK" ? "âœ…" : "âŒ"
                        formattedMetrics += "   ${conditionStatus} ${condition.metricKey}: ${condition.actualValue} (${condition.operator} ${condition.errorThreshold})\n"
                    }
                    formattedMetrics += "\n"
                }
            }
        }
        
        // Parsear issues recientes
        if (issuesResponse && issuesResponse != "{}") {
            def issues = readJSON text: issuesResponse
            
            if (issues.issues && issues.issues.size() > 0) {
                formattedMetrics += "ğŸš¨ ISSUES RECIENTES (Top 5):\n"
                formattedMetrics += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                
                issues.issues.take(5).each { issue ->
                    def severity = getSeverityEmoji(issue.severity)
                    formattedMetrics += "${severity} ${issue.severity.toUpperCase()}: ${issue.message}\n"
                    if (issue.line) {
                        formattedMetrics += "   ğŸ“ ${issue.component}:${issue.line}\n"
                    }
                    formattedMetrics += "   ğŸ·ï¸ ${issue.type}\n\n"
                }
            }
        }
        
    } catch (Exception e) {
        formattedMetrics += "Error parseando mÃ©tricas: ${e.getMessage()}\n"
    }
    
    if (!formattedMetrics) {
        formattedMetrics = " MÃ©tricas no disponibles o proyecto no encontrado\n"
    }
    
    return formattedMetrics
}

def getRatingEmoji(rating) {
    switch(rating.toInteger()) {
        case 1: return "ğŸŸ¢"
        case 2: return "ğŸŸ¡"
        case 3: return "ğŸŸ "
        case 4: return "ğŸ”´"
        case 5: return "âš«"
        default: return "â“"
    }
}

def getSeverityEmoji(severity) {
    switch(severity.toLowerCase()) {
        case "blocker": return "ğŸš«"
        case "critical": return "ğŸ’¥"
        case "major": return "âš ï¸"
        case "minor": return "ğŸ’¡"
        case "info": return "â„¹ï¸"
        default: return "â“"
    }
}

def getDebtStatus(hours) {
    def debtHours = hours.toInteger()
    if (debtHours <= 8) return "âœ…"
    if (debtHours <= 16) return "âš ï¸"
    return "âŒ"
}

def formatDebt(hours) {
    def debtHours = hours.toInteger()
    if (debtHours < 24) {
        return "${debtHours}h"
    } else if (debtHours < 168) { // 7 dÃ­as
        def days = debtHours / 24
        return "${days.round(1)}d"
    } else {
        def weeks = debtHours / 168
        return "${weeks.round(1)}w"
    }
} 