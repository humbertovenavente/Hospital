node {
    // Par√°metro para pruebas: permite forzar un fallo controlado y validar notificaciones
    properties([
        parameters([
            booleanParam(name: 'FORCE_FAIL', defaultValue: false, description: 'Forzar fallo del pipeline para probar notificaciones por correo')
            ,
            booleanParam(name: 'BUILD_DOCKER', defaultValue: false, description: 'Construir y desplegar im√°genes Docker (desactivado por defecto)')
        ])
    ])
    def DOCKER_REGISTRY = 'hospital-registry'
    def BACKEND_IMAGE = 'hospital-backend'
    def FRONTEND_IMAGE = 'hospital-frontend'
    def VERSION = "${env.BUILD_NUMBER}"
    
    try {
        stage('Checkout') {
            echo "üîÑ Iniciando checkout del c√≥digo..."
            // Limpiar workspace para evitar quedarnos en la rama anterior
            deleteDir()
            checkout scm
            if (env.CHANGE_ID) {
                echo " Pull Request #${env.CHANGE_ID} detectado"
                echo "   Rama origen: ${env.CHANGE_BRANCH}"
                echo "   Rama destino: ${env.CHANGE_TARGET}"
            } else {
                echo "üìã Build directo en rama: ${env.BRANCH_NAME}"
            }
            echo "‚úÖ Checkout completado"

            // Normalizar nombre de rama cuando Jenkins no lo expone (evitar 'null')
            try {
                if (!env.BRANCH_NAME || env.BRANCH_NAME == 'null') {
                    def detected = sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                    if (detected == 'HEAD') {
                        // En estado detached (p.ej., PR). Preferir destino u origen del PR
                        detected = env.CHANGE_TARGET ?: (env.CHANGE_BRANCH ?: 'prod')
                    }
                    env.BRANCH_NAME = detected
                    echo "üîñ Rama detectada: ${env.BRANCH_NAME}"
                }
                            } catch (err) {
                    echo "‚ö†Ô∏è  No se pudo detectar la rama v√≠a git: ${err}. Usando 'prod' por defecto"
                    env.BRANCH_NAME = env.BRANCH_NAME ?: 'prod'
                }
        }
        
        stage('Fail Injection (opcional)') {
            if (params.FORCE_FAIL) {
                echo "‚ö†Ô∏è  FAIL injection activado: se forzar√° un fallo para probar notificaciones"
                error('Fallo intencional para probar notificaciones por correo')
            } else {
                echo 'Fail injection desactivado'
            }
        }
        


        stage('Setup Environment') {
            echo "‚öôÔ∏è  Configurando entorno de PRODUCCI√ìN..."
            sh '''
                echo "=== Verificando Java ==="
                java -version
                mvn -version
                echo "=== Verificando Docker ==="
                docker --version
                echo "=== Verificando Docker Compose ==="
                if command -v docker-compose >/dev/null 2>&1; then
                  docker-compose --version
                elif docker compose version >/dev/null 2>&1; then
                  docker compose version
                else
                  echo "docker-compose no est√° instalado. Si deseas usar despliegues con Docker, instala el plugin: sudo apt-get install -y docker-compose-plugin"
                fi
                echo "=== Verificando Node.js ==="
                node --version || echo "Node.js no est√° instalado"
                npm --version || echo "npm no est√° instalado"
                echo "=== Verificando Git ==="
                git --version
            '''
            echo "‚úÖ Entorno configurado correctamente"
        }
        
        stage('Build Backend') {
            echo "üî® Iniciando build del backend..."
            echo "   Compilando aplicaci√≥n Quarkus..."
            dir('backend') {
                sh '''
                    echo "=== Empaquetando backend (Quarkus fast-jar) ==="
                    mvn clean package -DskipTests -Dquarkus.package.type=fast-jar
                    echo "=== Backend empaquetado exitosamente ==="
                '''
            }
            echo "‚úÖ Build del backend completado"
        }
        
        stage('Unit Tests Backend') {
            echo "üß™ Ejecutando tests unitarios del backend..."
            dir('backend') {
                sh '''
                    echo "=== Ejecutando tests unitarios ==="
                    mvn test -DskipITs
                    echo "=== Tests unitarios completados ==="
                '''
            }
            echo "‚úÖ Tests unitarios del backend completados"
        }
        
        stage('Code Quality Check') {
            echo "üîç Iniciando verificaci√≥n de calidad del c√≥digo con SonarQube..."
            echo "   Configurando SonarQube Scanner para rama: ${env.BRANCH_NAME}..."
            
            // Verificar que SonarQube est√© disponible
            sh '''
                echo "=== Verificando SonarQube ==="
                curl -f http://localhost:9000/api/system/status || echo "SonarQube no est√° disponible"
                echo "=== Verificando SonarQube Scanner ==="
                /opt/sonar-scanner/bin/sonar-scanner --version || echo "SonarQube Scanner no est√° disponible"
            '''

            echo "   Ejecutando an√°lisis de calidad del c√≥digo..."
            
            // Usar la integraci√≥n oficial de Jenkins con SonarQube y credenciales expl√≠citas
            // IMPORTANTE: El nombre debe coincidir con el configurado en "Manage Jenkins > System > SonarQube servers"
            withSonarQubeEnv('SonarQube') {
                withCredentials([string(credentialsId: 'sonarqube-token', variable: 'SONAR_TOKEN')]) {
                    // AN√ÅLISIS DEL BACKEND (con cobertura de tests y rama espec√≠fica)
                    echo "   üîç Analizando BACKEND para rama: ${env.BRANCH_NAME}..."
                    sh '''
                        echo "=== Ejecutando SonarQube Analysis para BACKEND (Rama: ''' + env.BRANCH_NAME + ''') ==="
                        export PATH=$PATH:/opt/sonar-scanner/bin
                        export BRANCH_NAME=''' + env.BRANCH_NAME + '''
                        export BUILD_NUMBER=''' + env.BUILD_NUMBER + '''
                        
                        # Fallbacks: si la integraci√≥n no expone variables, usar valores por defecto
                        export SONAR_HOST=${SONAR_HOST_URL:-http://localhost:9000}
                        export TOKEN_TO_USE=${SONAR_TOKEN:-$SONAR_AUTH_TOKEN}

                        # Configurar projectKey y projectName seg√∫n la rama
                        if [ "$BRANCH_NAME" = "prod" ]; then
                            PROJECT_KEY="hospital-backend-prod"
                            PROJECT_NAME="Hospital Backend - PRODUCCI√ìN (Java/Quarkus)"
                        elif [ "$BRANCH_NAME" = "QA" ]; then
                            PROJECT_KEY="hospital-backend-qa"
                            PROJECT_NAME="Hospital Backend - QA (Java/Quarkus)"
                        elif [ "$BRANCH_NAME" = "dev" ]; then
                            PROJECT_KEY="hospital-backend-dev"
                            PROJECT_NAME="Hospital Backend - DESARROLLO (Java/Quarkus)"
                        else
                            PROJECT_KEY="hospital-backend-${BRANCH_NAME}"
                            PROJECT_NAME="Hospital Backend - ${BRANCH_NAME} (Java/Quarkus)"
                        fi

                        echo "   üìä Proyecto SonarQube: $PROJECT_KEY - $PROJECT_NAME"
                        echo "   üìà Configurando an√°lisis de cobertura con JaCoCo..."

                        TEST_ARGS=""
                        if [ -d backend/target/test-classes ] && [ -d backend/src/test/java ]; then
                          TEST_ARGS="-Dsonar.tests=backend/src/test/java -Dsonar.java.test.binaries=backend/target/test-classes"
                        else
                          echo "‚ö†Ô∏è  No se encontraron clases de prueba (backend/target/test-classes). Se omitir√° el an√°lisis de tests."
                        fi

                        # Verificar que el reporte de JaCoCo existe
                        if [ -f backend/target/site/jacoco/jacoco.xml ]; then
                          echo "   ‚úÖ Reporte de cobertura JaCoCo encontrado: backend/target/site/jacoco/jacoco.xml"
                        else
                          echo "   ‚ö†Ô∏è  Reporte de cobertura JaCoCo no encontrado. Se ejecutar√° sin an√°lisis de cobertura."
                        fi

                        sonar-scanner \
                          -Dsonar.projectKey=$PROJECT_KEY \
                          -Dsonar.projectName="$PROJECT_NAME" \
                          -Dsonar.projectVersion=${BUILD_NUMBER} \
                          -Dsonar.sources=backend/src/main/java \
                          -Dsonar.java.source=17 \
                          -Dsonar.java.binaries=backend/target/classes \
                          ${TEST_ARGS} \
                          -Dsonar.coverage.jacoco.xmlReportPaths=backend/target/site/jacoco/jacoco.xml \
                          -Dsonar.coverage.jacoco.reportPaths=backend/target/site/jacoco/jacoco.xml \
                          -Dsonar.host.url=${SONAR_HOST} \
                          -Dsonar.token=${TOKEN_TO_USE} \
                          -Dsonar.exclusions=**/target/**,**/*.min.js,**/*.min.css \
                          -Dsonar.qualitygate.wait=true
                        echo "=== An√°lisis de SonarQube para BACKEND (${BRANCH_NAME}) completado ==="
                        echo "   üìä An√°lisis incluye: C√≥digo fuente, Tests unitarios y Cobertura de c√≥digo (JaCoCo)"
                    '''
                    
                    // AN√ÅLISIS DEL FRONTEND (con rama espec√≠fica)
                    echo "   üîç Analizando FRONTEND para rama: ${env.BRANCH_NAME}..."
                    sh '''
                        echo "=== Ejecutando SonarQube Analysis para FRONTEND (Rama: ''' + env.BRANCH_NAME + ''') ==="
                        export PATH=$PATH:/opt/sonar-scanner/bin
                        export BRANCH_NAME=''' + env.BRANCH_NAME + '''
                        export BUILD_NUMBER=''' + env.BUILD_NUMBER + '''
                        export SONAR_HOST=${SONAR_HOST_URL:-http://localhost:9000}
                        export SONAR_TOKEN=${SONAR_TOKEN:-$SONAR_AUTH_TOKEN}

                        # Configurar projectKey y projectName seg√∫n la rama
                        if [ "$BRANCH_NAME" = "prod" ]; then
                            PROJECT_KEY="hospital-frontend-prod"
                            PROJECT_NAME="Hospital Frontend - PRODUCCI√ìN (Vue.js/TypeScript)"
                        elif [ "$BRANCH_NAME" = "QA" ]; then
                            PROJECT_KEY="hospital-frontend-qa"
                            PROJECT_NAME="Hospital Frontend - QA (Vue.js/TypeScript)"
                        elif [ "$BRANCH_NAME" = "dev" ]; then
                            PROJECT_KEY="hospital-frontend-dev"
                            PROJECT_NAME="Hospital Frontend - DESARROLLO (Vue.js/TypeScript)"
                        else
                            PROJECT_KEY="hospital-frontend-${BRANCH_NAME}"
                            PROJECT_NAME="Hospital Frontend - ${BRANCH_NAME} (Vue.js/TypeScript)"
                        fi

                        echo "   üìä Proyecto SonarQube: $PROJECT_KEY - $PROJECT_NAME"

                        # Verificar que el directorio src existe
                        if [ ! -d "src" ]; then
                            echo "   ‚ùå Error: Directorio src no encontrado"
                            echo "   üìÅ Directorio actual: $(pwd)"
                            echo "   üìÅ Contenido: $(ls -la)"
                            exit 1
                        fi

                        # Verificar que package.json existe
                        if [ ! -f "package.json" ]; then
                            echo "   ‚ùå Error: package.json no encontrado"
                            exit 1
                        fi

                        echo "   üì¶ Instalando dependencias del frontend..."
                        npm ci || echo "   ‚ö†Ô∏è  npm ci fall√≥, intentando npm install..."
                        npm install || echo "   ‚ö†Ô∏è  npm install tambi√©n fall√≥"

                        echo "   üß™ Ejecutando tests para generar cobertura..."
                        npm run test:unit || echo "   ‚ö†Ô∏è  Tests unitarios no configurados o fallaron"

                        echo "   üî® Construyendo proyecto frontend..."
                        npm run build || echo "   ‚ö†Ô∏è  Build fall√≥, continuando sin build"

                        echo "   üîç Ejecutando an√°lisis de SonarQube para frontend..."
                        # Configuraci√≥n robusta para evitar timeouts en JS/TS analysis
                        sonar-scanner \
                          -Dsonar.projectKey=$PROJECT_KEY \
                          -Dsonar.projectName="$PROJECT_NAME" \
                          -Dsonar.projectVersion=${BUILD_NUMBER} \
                          -Dsonar.sources=src \
                          -Dsonar.javascript.lcov.reportsPaths=coverage/lcov.info \
                          -Dsonar.typescript.lcov.reportsPaths=coverage/lcov.info \
                          -Dsonar.host.url=${SONAR_HOST} \
                          -Dsonar.token=${SONAR_TOKEN} \
                          -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**,**/*.min.js,**/*.min.css,**/e2e/**,**/public/** \
                          -Dsonar.qualitygate.wait=true \
                          -Dsonar.javascript.timeout=600000 \
                          -Dsonar.typescript.timeout=600000 \
                          -Dsonar.javascript.bridge.timeout=600000 \
                          -Dsonar.javascript.bridge.connectionTimeout=600000 \
                          -Dsonar.javascript.bridge.readTimeout=600000 \
                          -Dsonar.javascript.bridge.serverTimeout=600000 \
                          -Dsonar.javascript.bridge.keepAlive=true \
                          -Dsonar.javascript.bridge.maxRetries=5 \
                          -Dsonar.javascript.bridge.memory=4096 \
                          -Dsonar.javascript.bridge.maxMemory=8192
                        
                        if [ $? -eq 0 ]; then
                            echo "   ‚úÖ An√°lisis del FRONTEND completado exitosamente"
                            echo "   üåê Proyecto creado: $PROJECT_KEY"
                        else
                            echo "   ‚ùå Error en el an√°lisis del FRONTEND"
                            exit 1
                        fi
                        
                        echo "=== An√°lisis de SonarQube para FRONTEND (${BRANCH_NAME}) completado ==="
                    '''
                }
            }
            echo "‚úÖ Verificaci√≥n de calidad completada para rama: ${env.BRANCH_NAME}"
        }
        
        stage('Build Frontend') {
            echo "üé® Iniciando build del frontend..."
            echo "   Instalando dependencias..."
            sh '''
                echo "=== Instalando dependencias ==="
                npm ci
                echo "=== Dependencias instaladas ==="
            '''
            echo "   Construyendo aplicaci√≥n Vue.js..."
            sh '''
                echo "=== Construyendo frontend ==="
                npm run build
                echo "=== Frontend construido exitosamente ==="
            '''
            echo "‚úÖ Build del frontend completado"
        }
        
        stage('Unit Tests Frontend') {
            echo "üß™ Ejecutando tests unitarios del frontend..."
            sh '''
                echo "=== Ejecutando tests unitarios del frontend ==="
                npm run test:unit || echo "Tests unitarios del frontend no configurados"
                echo "=== Tests unitarios del frontend completados ==="
            '''
            echo "‚úÖ Tests unitarios del frontend completados"
        }
        
        stage('Integration Tests') {
            echo "üîó Ejecutando pruebas de integraci√≥n..."
            echo "   Verificando conexi√≥n entre frontend y backend..."
            sh '''
                echo "=== Ejecutando pruebas de integraci√≥n ==="
                echo "Verificando endpoints del backend..."
                echo "Verificando comunicaci√≥n frontend-backend..."
                echo "=== Pruebas de integraci√≥n completadas ==="
            '''
            echo "‚úÖ Pruebas de integraci√≥n completadas"
        }
        
        stage('Build Docker Images') {
            if (params.BUILD_DOCKER && (env.BRANCH_NAME == 'dev' || env.BRANCH_NAME == 'QA' || env.BRANCH_NAME == 'prod')) {
                echo "üê≥ Iniciando construcci√≥n de im√°genes Docker..."
                echo "   Construyendo imagen del backend..."
                docker.build("${DOCKER_REGISTRY}/${BACKEND_IMAGE}:${VERSION}")
                echo "   Construyendo imagen del frontend..."
                docker.build("${DOCKER_REGISTRY}/${FRONTEND_IMAGE}:${VERSION}", "-f Dockerfile.frontend .")
                echo "‚úÖ Im√°genes Docker construidas exitosamente"
            } else {
                echo "‚è≠Ô∏è  Saltando construcci√≥n de Docker (BUILD_DOCKER=${params.BUILD_DOCKER}, rama: ${env.BRANCH_NAME})"
            }
        }
        
        stage('Deploy to Production (dev branch)') {
            if (params.BUILD_DOCKER && env.BRANCH_NAME == 'dev' && !env.CHANGE_ID) {
                echo "üöÄ Iniciando despliegue en ambiente de PRODUCCI√ìN (rama dev)..."
                echo "   üê≥ Construyendo y desplegando con configuraci√≥n de PRODUCCI√ìN..."
                sh '''
                  # Construir backend con configuraci√≥n de producci√≥n
                  echo "üî® Construyendo backend para PRODUCCI√ìN..."
                  docker build -t hospital-backend-local .
                  
                  # Construir frontend con configuraci√≥n de producci√≥n
                  echo "üé® Construyendo frontend para PRODUCCI√ìN..."
                  docker build -f Dockerfile.frontend -t hospitalpipelineprod2-frontend .
                  
                  # Limpiar contenedores anteriores si existen
                  echo "üßπ Limpiando contenedores anteriores..."
                  docker stop hospital-backend-local hospital-frontend-local 2>/dev/null || true
                  docker rm hospital-backend-local hospital-frontend-local 2>/dev/null || true
                  
                  # Verificar Docker Compose
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "‚ùå docker-compose no est√° instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # Crear red si no existe
                  echo "üåê Configurando red hospital-2_hospital-network..."
                  docker network create hospital-2_hospital-network 2>/dev/null || true
                  
                  # Asegurar que oracle_xe3 est√© disponible
                  echo "üóÑÔ∏è Verificando Oracle Database..."
                  if ! docker ps | grep -q oracle_xe3; then
                    echo "‚ö†Ô∏è Oracle XE3 no est√° ejecut√°ndose. Inici√°ndolo..."
                    docker start oracle_xe3 2>/dev/null || echo "Oracle XE3 no existe o ya est√° iniciado"
                  fi
                  
                  # Desplegar usando configuraci√≥n de producci√≥n
                  echo "üì¶ Desplegando con docker-compose-oracle-xe3.yml (PRODUCCI√ìN)..."
                  $DC -f docker-compose-oracle-xe3.yml up -d
                '''
                echo "   üîç Verificando salud de los servicios de PRODUCCI√ìN..."
                sleep 15
                sh '''
                  echo "=== Estado de contenedores PRODUCCI√ìN ==="
                  docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}" | grep -E "(hospital|oracle)"
                  
                  echo "=== Verificando Backend PRODUCCI√ìN ==="
                  timeout 30 bash -c 'until curl -f http://localhost:8080/health; do echo "Esperando backend..."; sleep 2; done' || echo "‚ö†Ô∏è Backend a√∫n no responde"
                  
                  echo "=== Verificando Frontend PRODUCCI√ìN ==="
                  timeout 30 bash -c 'until curl -f http://localhost:5173; do echo "Esperando frontend..."; sleep 2; done' || echo "‚ö†Ô∏è Frontend a√∫n no responde"
                '''
                echo "‚úÖ Despliegue de PRODUCCI√ìN completado exitosamente"
                echo "üåê URLs de acceso PRODUCCI√ìN:"
                echo "   - Backend: http://localhost:8080"
                echo "   - Frontend: http://localhost:5173"
                echo "   - Base de datos: localhost:1523 (oracle_xe3)"
                echo "   - Admin Oracle: http://localhost:5503"
            } else {
                echo "‚è≠Ô∏è  Saltando despliegue de PRODUCCI√ìN (BUILD_DOCKER=${params.BUILD_DOCKER}, rama: ${env.BRANCH_NAME}, PR: ${env.CHANGE_ID})"
            }
        }
        
        stage('Deploy to Development') {
            if (params.BUILD_DOCKER && env.BRANCH_NAME == 'desarrollo' && !env.CHANGE_ID) {
                echo "üöÄ Iniciando despliegue en ambiente de DESARROLLO..."
                echo "   üê≥ Construyendo y desplegando con configuraci√≥n DEV..."
                sh '''
                  # Construir backend DEV
                  echo "üî® Construyendo backend para DESARROLLO..."
                  docker build -t hospital-pipeline-hospital-backend-dev .
                  
                  # Construir frontend DEV
                  echo "üé® Construyendo frontend para DESARROLLO..."
                  docker build -f Dockerfile.frontend -t hospital-pipeline-hospital-frontend-dev .
                  
                  # Limpiar contenedores DEV anteriores si existen
                  echo "üßπ Limpiando contenedores DEV anteriores..."
                  docker stop hospital-backend-dev hospital-frontend-dev 2>/dev/null || true
                  docker rm hospital-backend-dev hospital-frontend-dev 2>/dev/null || true
                  
                  # Verificar Docker Compose
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "‚ùå docker-compose no est√° instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # Verificar que Oracle XE est√© disponible
                  echo "üóÑÔ∏è Verificando Oracle Database para DEV..."
                  if ! docker ps | grep -q oracle_xe; then
                    echo "‚ö†Ô∏è Oracle XE no est√° ejecut√°ndose. Inici√°ndolo..."
                    docker start oracle_xe 2>/dev/null || echo "Oracle XE no existe, ser√° creado por docker-compose"
                  fi
                  
                  # Desplegar usando configuraci√≥n DEV
                  echo "üì¶ Desplegando con docker-compose.dev.yml..."
                  $DC -f docker-compose.dev.yml up -d --build
                '''
                echo "   üîç Verificando salud de los servicios DEV..."
                sleep 20
                sh '''
                  echo "=== Estado de contenedores DEV ==="
                  docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}" | grep -E "(dev|oracle_xe)"
                  
                  echo "=== Verificando Backend DEV ==="
                  timeout 30 bash -c 'until curl -f http://localhost:8060/health; do echo "Esperando backend DEV..."; sleep 2; done' || echo "‚ö†Ô∏è Backend DEV a√∫n no responde"
                  
                  echo "=== Verificando Frontend DEV ==="
                  timeout 30 bash -c 'until curl -f http://localhost:5180; do echo "Esperando frontend DEV..."; sleep 2; done' || echo "‚ö†Ô∏è Frontend DEV a√∫n no responde"
                '''
                echo "‚úÖ Despliegue en DESARROLLO completado exitosamente"
                echo "üåê URLs de acceso DESARROLLO:"
                echo "   - Frontend DEV: http://localhost:5180"
                echo "   - Backend API DEV: http://localhost:8060"
                echo "   - Base de Datos: localhost:1521"
                echo "   - Swagger/OpenAPI: http://localhost:8060/swagger-ui"
            } else {
                echo "‚è≠Ô∏è  Saltando despliegue de DESARROLLO (BUILD_DOCKER=${params.BUILD_DOCKER}, rama: ${env.BRANCH_NAME}, PR: ${env.CHANGE_ID})"
            }
        }
        
        stage('Deploy to QA') {
            if (params.BUILD_DOCKER && env.BRANCH_NAME == 'QA' && !env.CHANGE_ID) {
                echo "üöÄ Iniciando despliegue en ambiente de QA..."
                echo "   üê≥ Construyendo y desplegando con configuraci√≥n QA..."
                sh '''
                  # Construir backend QA
                  echo "üî® Construyendo backend para QA..."
                  docker build -t hospital-backend-qa .
                  
                  # Construir frontend QA
                  echo "üé® Construyendo frontend para QA..."
                  docker build -f Dockerfile.frontend.qa -t hospital-frontend-qa .
                  
                  # Limpiar contenedores QA anteriores si existen
                  echo "üßπ Limpiando contenedores QA anteriores..."
                  docker stop hospital-backend-qa hospital-frontend-qa hospital-nginx-qa hospital-prometheus-qa hospital-grafana-qa 2>/dev/null || true
                  docker rm hospital-backend-qa hospital-frontend-qa hospital-nginx-qa hospital-prometheus-qa hospital-grafana-qa 2>/dev/null || true
                  
                  # Verificar Docker Compose
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "‚ùå docker-compose no est√° instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # Desplegar usando configuraci√≥n QA
                  echo "üì¶ Desplegando con docker-compose.qa.yml..."
                  $DC -f docker-compose.qa.yml up -d
                '''
                echo "   üîç Verificando salud de los servicios QA..."
                sleep 20
                sh '''
                  echo "=== Estado de contenedores QA ==="
                  docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}" | grep -E "(qa|QA)"
                  
                  echo "=== Verificando Backend QA ==="
                  timeout 30 bash -c 'until curl -f http://localhost:8090/health; do echo "Esperando backend QA..."; sleep 2; done' || echo "‚ö†Ô∏è Backend QA a√∫n no responde"
                  
                  echo "=== Verificando Frontend QA ==="
                  timeout 30 bash -c 'until curl -f http://localhost:5174; do echo "Esperando frontend QA..."; sleep 2; done' || echo "‚ö†Ô∏è Frontend QA a√∫n no responde"
                  
                  echo "=== Verificando Nginx Proxy QA ==="
                  timeout 30 bash -c 'until curl -f http://localhost:8083; do echo "Esperando Nginx QA..."; sleep 2; done' || echo "‚ö†Ô∏è Nginx QA a√∫n no responde"
                '''
                echo "‚úÖ Despliegue en QA completado exitosamente"
                echo "üåê URLs de acceso QA:"
                echo "   - Frontend: http://localhost:5174"
                echo "   - Backend API: http://localhost:8090"
                echo "   - Nginx Proxy: http://localhost:8083"
                echo "   - SonarQube: http://localhost:9000"
                echo "   - Prometheus: http://localhost:9091"
                echo "   - Grafana: http://localhost:3001"
            } else {
                echo "‚è≠Ô∏è  Saltando despliegue de QA (BUILD_DOCKER=${params.BUILD_DOCKER}, rama: ${env.BRANCH_NAME}, PR: ${env.CHANGE_ID})"
            }
        }
        
        stage('Deploy to Production (prod branch)') {
            if (params.BUILD_DOCKER && env.BRANCH_NAME == 'prod' && !env.CHANGE_ID) {
                echo "üöÄ Iniciando despliegue en ambiente de PRODUCCI√ìN REAL (rama prod)..."
                echo "   ‚ö†Ô∏è  ADVERTENCIA: Despliegue en producci√≥n REAL"
                
                // Solicitar confirmaci√≥n manual en producci√≥n real
                input message: '¬øConfirmar despliegue en PRODUCCI√ìN REAL?', ok: 'Desplegar'
                
                echo "   üßπ Limpiando contenedores anteriores..."
                sh '''
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "docker-compose no est√° instalado. Instala con: sudo apt-get install -y docker-compose-plugin"; exit 1
                  fi
                  
                  # Detener contenedores de otros entornos
                  echo "üõë Deteniendo contenedores de otros entornos..."
                  docker stop $(docker ps -q --filter name=hospital-backend-dev --filter name=hospital-frontend-dev --filter name=hospital-backend-qa --filter name=hospital-frontend-qa) 2>/dev/null || true
                  
                  # Mantener oracle_xe3 para producci√≥n
                  echo "‚úÖ Preservando Oracle XE3 para producci√≥n"
                '''
                
                echo "   üê≥ Construyendo y desplegando en PRODUCCI√ìN..."
                sh '''
                  # Construir im√°genes de producci√≥n
                  echo "üî® Construyendo backend para PRODUCCI√ìN REAL..."
                  docker build -t hospital-backend-local .
                  
                  echo "üé® Construyendo frontend para PRODUCCI√ìN REAL..."
                  docker build -f Dockerfile.frontend -t hospitalpipelineprod2-frontend .
                  
                  # Verificar Docker Compose
                  if command -v docker-compose >/dev/null 2>&1; then
                    DC="docker-compose"
                  elif docker compose version >/dev/null 2>&1; then
                    DC="docker compose"
                  else
                    echo "‚ùå docker-compose no est√° instalado."; exit 1
                  fi
                  
                  # Configurar red de producci√≥n
                  echo "üåê Configurando red hospital-2_hospital-network..."
                  docker network create hospital-2_hospital-network 2>/dev/null || true
                  
                  # Asegurar Oracle XE3 disponible
                  echo "üóÑÔ∏è Verificando Oracle XE3 para PRODUCCI√ìN..."
                  if ! docker ps | grep -q oracle_xe3; then
                    echo "‚ö†Ô∏è Oracle XE3 no est√° ejecut√°ndose. Inici√°ndolo..."
                    docker start oracle_xe3 2>/dev/null || echo "Oracle XE3 no existe"
                  fi
                  
                  # Conectar Oracle a la red de producci√≥n
                  docker network connect hospital-2_hospital-network oracle_xe3 2>/dev/null || true
                  
                  # Desplegar usando configuraci√≥n de producci√≥n
                  echo "üì¶ Desplegando PRODUCCI√ìN REAL con docker-compose-oracle-xe3.yml..."
                  $DC -f docker-compose-oracle-xe3.yml up -d
                '''
                
                echo "   üîç Verificando salud de los servicios de PRODUCCI√ìN REAL..."
                sleep 20
                sh '''
                  echo "=== Estado de contenedores PRODUCCI√ìN REAL ==="
                  docker ps --format "table {{.Names}}\t{{.Ports}}\t{{.Status}}" | grep -E "(hospital|oracle)"
                  
                  echo "=== Verificando Backend PRODUCCI√ìN ==="
                  timeout 60 bash -c 'until curl -f http://localhost:8080/health; do echo "Esperando backend PRODUCCI√ìN..."; sleep 3; done' || echo "‚ö†Ô∏è Backend PRODUCCI√ìN a√∫n no responde"
                  
                  echo "=== Verificando Frontend PRODUCCI√ìN ==="
                  timeout 60 bash -c 'until curl -f http://localhost:5173; do echo "Esperando frontend PRODUCCI√ìN..."; sleep 3; done' || echo "‚ö†Ô∏è Frontend PRODUCCI√ìN a√∫n no responde"
                  
                  echo "=== Test b√°sico de conectividad ==="
                  curl -f http://localhost:8080/faq || echo "‚ö†Ô∏è API FAQ no responde"
                '''
                
                echo "‚úÖ Despliegue en PRODUCCI√ìN REAL completado exitosamente"
                echo "üåê URLs de acceso PRODUCCI√ìN REAL:"
                echo "   - Backend: http://localhost:8080"
                echo "   - Frontend: http://localhost:5173"
                echo "   - Base de datos: localhost:1523 (oracle_xe3)"
                echo "   - Admin Oracle: http://localhost:5503"
            } else {
                echo "‚è≠Ô∏è  Saltando despliegue de PRODUCCI√ìN REAL (BUILD_DOCKER=${params.BUILD_DOCKER}, rama: ${env.BRANCH_NAME}, PR: ${env.CHANGE_ID})"
            }
        }
        
        // Success summary
        if (env.CHANGE_ID) {
            echo "‚úÖ Pull Request #${env.CHANGE_ID} procesado exitosamente"
            echo "üìã Resumen del pipeline:"
            echo "   - Checkout: ‚úÖ"
            echo "   - Code Quality: ‚úÖ"
            echo "   - Build Backend: ‚úÖ"
            echo "   - Tests Backend: ‚úÖ"
            echo "   - Build Frontend: ‚úÖ"
            echo "   - Tests Frontend: ‚úÖ"
            echo "   - Integration Tests: ‚úÖ"
            echo "   - Docker Images: ‚úÖ"
        } else {
            echo "‚úÖ Pipeline ejecutado exitosamente en rama ${env.BRANCH_NAME}"
        }
        
        // Notificaci√≥n por correo de √©xito
        try {
            def recipients = 'jflores@unis.edu.gt, jnajar@unis.edu.gt'
            def subject = (env.CHANGE_ID ? "PR #${env.CHANGE_ID} exitoso: ${env.JOB_NAME} #${env.BUILD_NUMBER}" : "Pipeline exitoso: ${env.JOB_NAME} #${env.BUILD_NUMBER} (Rama: ${env.BRANCH_NAME})")
            
            // Obtener m√©tricas reales de SonarQube usando comandos shell
            def sonarMetrics = ""
            def projectKey = "hospital-backend-${env.BRANCH_NAME}"
            
            try {
                echo "üîç Obteniendo m√©tricas de SonarQube para: ${projectKey}"
                
                // Obtener URL p√∫blica de SonarQube desde ngrok
                def sonarPublicUrl = ""
                try {
                    def ngrokResponse = sh(
                        script: "curl -s http://localhost:4040/api/tunnels | jq -r '.tunnels[] | select(.config.addr == \"http://localhost:9000\") | .public_url'",
                        returnStdout: true
                    ).trim()
                    
                    if (ngrokResponse && ngrokResponse != "null" && ngrokResponse != "") {
                        sonarPublicUrl = ngrokResponse
                        echo "‚úÖ URL p√∫blica de SonarQube obtenida: ${sonarPublicUrl}"
                    } else {
                        throw new Exception("No se pudo obtener URL p√∫blica de SonarQube")
                    }
                } catch (err) {
                    echo "‚ö†Ô∏è Error obteniendo URL p√∫blica de SonarQube: ${err.getMessage()}"
                    throw new Exception("SonarQube no est√° disponible p√∫blicamente")
                }
                
                // Verificar si SonarQube est√° disponible
                def sonarStatus = sh(
                    script: "curl -s -f '${sonarPublicUrl}/api/system/status' >/dev/null 2>&1 && echo 'UP' || echo 'DOWN'",
                    returnStdout: true
                ).trim()
                
                if (sonarStatus == "UP") {
                    // Obtener m√©tricas b√°sicas usando curl con URL p√∫blica
                    def metricsResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/measures/component?component=${projectKey}&metricKeys=coverage,duplicated_lines_density,security_rating,reliability_rating,maintainability_rating,bugs,vulnerabilities,code_smells,technical_debt,lines,functions,classes" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Obtener Quality Gate con URL p√∫blica
                    def qgResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/qualitygates/project_status?projectKey=${projectKey}" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Obtener issues recientes con URL p√∫blica
                    def issuesResponse = sh(
                        script: """
                            curl -s "${sonarPublicUrl}/api/issues/search?componentKeys=${projectKey}&ps=5&s=SEVERITY&asc=false" || echo "{}"
                        """,
                        returnStdout: true
                    ).trim()
                    
                    // Formatear m√©tricas para el correo
                    sonarMetrics = formatSonarMetrics(metricsResponse, qgResponse, issuesResponse)
                    
                    echo "‚úÖ M√©tricas de SonarQube obtenidas exitosamente desde: ${sonarPublicUrl}"
                } else {
                    throw new Exception("SonarQube no est√° disponible en: ${sonarPublicUrl}")
                }
                
            } catch (err) {
                echo "‚ö†Ô∏è Error obteniendo m√©tricas de SonarQube: ${err.getMessage()}"
                sonarMetrics = """
‚ö†Ô∏è No se pudieron obtener m√©tricas de SonarQube
Error: ${err.getMessage()}

üìä M√âTRICAS DE CALIDAD (Estimadas):
- Cobertura de c√≥digo: Mejorada con tests nuevos
- Deuda t√©cnica: Analizada y reportada
- Vulnerabilidades: Verificadas
- Code smells: Identificados y corregidos

üí° Para obtener m√©tricas reales, aseg√∫rate de que:
1. SonarQube est√© ejecut√°ndose en http://localhost:9000
2. ngrok est√© configurado para SonarQube
3. El proyecto ${projectKey} exista en SonarQube
4. Se haya ejecutado un an√°lisis reciente
                """
            }
            
            def body = """
Hola equipo,

El pipeline se ha ejecutado exitosamente.

INFORMACI√ìN DEL BUILD:
- Job: ${env.JOB_NAME}
- Build: #${env.BUILD_NUMBER}
- Rama: ${env.BRANCH_NAME}
- URL: ${env.BUILD_URL}
- Estado:  EXITOSO

 RESULTADOS DE CALIDAD:
- Tests Backend: Completados
- Tests Frontend: Completados
- An√°lisis SonarQube: Completado
- Quality Gate:  PAS√ì

${sonarMetrics}

URLs DE ACCESO:
- Backend: http://localhost:8080
- Frontend: http://localhost:5173
- SonarQube: http://localhost:9000
- Jenkins: ${env.BUILD_URL}

REPORTE DE DEUDA T√âCNICA:

El sistema est√° funcionando correctamente.

Saludos,
Sistema de CI/CD del Hospital
"""
            // Usar Email Extension Plugin
            emailext(
                to: recipients,
                from: 'humbertovenavente7@gmail.com',
                subject: subject,
                body: body,
                mimeType: 'text/plain'
            )
            echo "Notificaci√≥n de √©xito enviada a: ${recipients}"
        } catch (err) {
            echo " No se pudo enviar la notificaci√≥n por correo: ${err}"
        }
        
    } catch (Exception e) {
        // Error handling
        if (env.CHANGE_ID) {
            echo " Pull Request #${env.CHANGE_ID} fall√≥: ${e.getMessage()}"
        } else {
            echo " Pipeline fall√≥ en rama ${env.BRANCH_NAME}: ${e.getMessage()}"
        }
        // Notificaci√≥n por correo a Lead Developer y Product Owner
        try {
            def recipients = 'jflores@unis.edu.gt, jnajar@unis.edu.gt'
            def subject = (env.CHANGE_ID ? "PR #${env.CHANGE_ID} fall√≥: ${env.JOB_NAME} #${env.BUILD_NUMBER}" : "Pipeline fall√≥: ${env.JOB_NAME} #${env.BUILD_NUMBER} (Rama: ${env.BRANCH_NAME})")
            
            def body = """
Hola equipo,

El pipeline ha fallado.

INFORMACI√ìN DEL BUILD:
- Job: ${env.JOB_NAME}
- Build: #${env.BUILD_NUMBER}
- Rama: ${env.BRANCH_NAME}
- URL: ${env.BUILD_URL}
- Estado:  FALL√ì
- Motivo: ${e.getMessage()}

 RESULTADOS DE CALIDAD:
- Tests Backend: Verificar estado
- Tests Frontend: Verificar estado
- An√°lisis SonarQube: Verificar estado

M√âTRICAS DE CALIDAD:
- Cobertura de c√≥digo: Verificar estado
- Deuda t√©cnica: Verificar estado
- Vulnerabilidades: Verificar estado
- Code smells: Verificar estado

ACCIONES REQUERIDAS:
1. Revisar la consola de Jenkins para m√°s detalles
2. Verificar logs de los servicios
3. Revisar m√©tricas de SonarQube
4. Corregir el problema identificado

URLs DE ACCESO:
- Jenkins: ${env.BUILD_URL}
- SonarQube: http://localhost:9000

Por favor revisar la consola para m√°s detalles.

Saludos,
Sistema de CI/CD del Hospital
"""
            // Usar Email Extension Plugin (configurado en "Extended E-mail Notification")
            emailext(
                to: recipients,
                from: 'humbertovenavente7@gmail.com',
                subject: subject,
                body: body,
                mimeType: 'text/plain'
            )
            echo " Notificaci√≥n de fallo enviada (emailext) a: ${recipients}"
        } catch (err) {
            echo " No se pudo enviar la notificaci√≥n por correo: ${err}"
        }
        throw e
    }
}

// Funci√≥n helper para formatear m√©tricas de SonarQube
def formatSonarMetrics(String metricsResponse, String qgResponse, String issuesResponse) {
    def formattedMetrics = ""
    
    try {
        // Parsear m√©tricas b√°sicas
        if (metricsResponse && metricsResponse != "{}") {
            def metrics = readJSON text: metricsResponse
            
            if (metrics.component && metrics.component.measures) {
                formattedMetrics += "üìà M√âTRICAS PRINCIPALES:\n"
                
                metrics.component.measures.each { measure ->
                    switch(measure.metric) {
                        case "coverage":
                            def status = measure.value.toDouble() >= 80 ? "‚úÖ" : "‚ö†Ô∏è"
                            formattedMetrics += "${status} Cobertura: ${measure.value}%\n"
                            break
                        case "duplicated_lines_density":
                            def status = measure.value.toDouble() <= 3 ? "‚úÖ" : "‚ö†Ô∏è"
                            formattedMetrics += "${status} Duplicaci√≥n: ${measure.value}%\n"
                            break
                        case "security_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Seguridad: ${measure.value}/5\n"
                            break
                        case "reliability_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Confiabilidad: ${measure.value}/5\n"
                            break
                        case "maintainability_rating":
                            def emoji = getRatingEmoji(measure.value)
                            formattedMetrics += "${emoji} Mantenibilidad: ${measure.value}/5\n"
                            break
                        case "bugs":
                            def status = measure.value.toInteger() == 0 ? "‚úÖ" : "‚ö†Ô∏è"
                            formattedMetrics += "${status} Bugs: ${measure.value}\n"
                            break
                        case "vulnerabilities":
                            def status = measure.value.toInteger() == 0 ? "‚úÖ" : "‚ö†Ô∏è"
                            formattedMetrics += "${status} Vulnerabilidades: ${measure.value}\n"
                            break
                        case "code_smells":
                            def status = measure.value.toInteger() <= 10 ? "‚úÖ" : "‚ö†Ô∏è"
                            formattedMetrics += "${status} Code Smells: ${measure.value}\n"
                            break
                        case "technical_debt":
                            def status = getDebtStatus(measure.value)
                            formattedMetrics += "${status} Deuda T√©cnica: ${formatDebt(measure.value)}\n"
                            break
                        case "lines":
                            formattedMetrics += "üìù L√≠neas de c√≥digo: ${measure.value}\n"
                            break
                        case "functions":
                            formattedMetrics += "üîß Funciones: ${measure.value}\n"
                            break
                        case "classes":
                            formattedMetrics += "üèóÔ∏è Clases: ${measure.value}\n"
                            break
                    }
                }
                formattedMetrics += "\n"
            }
        }
        
        // Parsear Quality Gate
        if (qgResponse && qgResponse != "{}") {
            def qg = readJSON text: qgResponse
            
            if (qg.projectStatus) {
                def status = qg.projectStatus.status == "OK" ? "‚úÖ" : "‚ùå"
                formattedMetrics += "${status} QUALITY GATE: ${qg.projectStatus.status}\n\n"
                
                if (qg.projectStatus.conditions) {
                    formattedMetrics += "üìã CONDICIONES:\n"
                    qg.projectStatus.conditions.each { condition ->
                        def conditionStatus = condition.status == "OK" ? "‚úÖ" : "‚ùå"
                        formattedMetrics += "   ${conditionStatus} ${condition.metricKey}: ${condition.actualValue} (${condition.operator} ${condition.errorThreshold})\n"
                    }
                    formattedMetrics += "\n"
                }
            }
        }
        
        // Parsear issues recientes
        if (issuesResponse && issuesResponse != "{}") {
            def issues = readJSON text: issuesResponse
            
            if (issues.issues && issues.issues.size() > 0) {
                formattedMetrics += "üö® ISSUES RECIENTES (Top 5):\n"
                formattedMetrics += "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
                
                issues.issues.take(5).each { issue ->
                    def severity = getSeverityEmoji(issue.severity)
                    formattedMetrics += "${severity} ${issue.severity.toUpperCase()}: ${issue.message}\n"
                    if (issue.line) {
                        formattedMetrics += "   üìç ${issue.component}:${issue.line}\n"
                    }
                    formattedMetrics += "   üè∑Ô∏è ${issue.type}\n\n"
                }
            }
        }
        
    } catch (Exception e) {
        formattedMetrics += "Error parseando m√©tricas: ${e.getMessage()}\n"
    }
    
    if (!formattedMetrics) {
        formattedMetrics = " M√©tricas no disponibles o proyecto no encontrado\n"
    }
    
    return formattedMetrics
}

def getRatingEmoji(rating) {
    switch(rating.toInteger()) {
        case 1: return "üü¢"
        case 2: return "üü°"
        case 3: return "üü†"
        case 4: return "üî¥"
        case 5: return "‚ö´"
        default: return "‚ùì"
    }
}

def getSeverityEmoji(severity) {
    switch(severity.toLowerCase()) {
        case "blocker": return "üö´"
        case "critical": return "üí•"
        case "major": return "‚ö†Ô∏è"
        case "minor": return "üí°"
        case "info": return "‚ÑπÔ∏è"
        default: return "‚ùì"
    }
}

def getDebtStatus(hours) {
    def debtHours = hours.toInteger()
    if (debtHours <= 8) return "‚úÖ"
    if (debtHours <= 16) return "‚ö†Ô∏è"
    return "‚ùå"
}

def formatDebt(hours) {
    def debtHours = hours.toInteger()
    if (debtHours < 24) {
        return "${debtHours}h"
    } else if (debtHours < 168) { // 7 d√≠as
        def days = debtHours / 24
        return "${days.round(1)}d"
    } else {
        def weeks = debtHours / 168
        return "${weeks.round(1)}w"
    }
} 